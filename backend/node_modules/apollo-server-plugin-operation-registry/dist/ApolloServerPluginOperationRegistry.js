"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./common");
const apollo_graphql_1 = require("apollo-graphql");
const apollo_server_errors_1 = require("apollo-server-errors");
const agent_1 = __importDefault(require("./agent"));
const apollo_server_caching_1 = require("apollo-server-caching");
const loglevel_1 = __importDefault(require("loglevel"));
function plugin(options = Object.create(null)) {
    let agent;
    let store;
    const logger = loglevel_1.default.getLogger(`apollo-server:${common_1.pluginName}`);
    const dryRunPrefix = '[DRYRUN]';
    if (options.debug === true) {
        logger.enableAll();
    }
    if (options.dryRun === true && options.debug !== false) {
        logger.enableAll();
        logger.debug(`${dryRunPrefix} Operation registry logging enabled because options.dryRun is true.`);
        if (options.forbidUnregisteredOperations) {
            logger.info(`${dryRunPrefix} Allowing all operations since options.dryRun is true. \
Operations will still be reported to Apollo trace warehouse as forbidden \
for observability purposes, but all operations will be permitted.`);
        }
    }
    Object.freeze(options);
    return () => ({
        async serverWillStart({ apollo, }) {
            logger.debug('Initializing operation registry plugin.');
            const { graphRef, keyHash } = apollo;
            if (!keyHash) {
                const messageApolloConfigurationRequired = 'The Apollo API key must be set to use the operation registry.';
                throw new Error(`${common_1.pluginName}: ${messageApolloConfigurationRequired}`);
            }
            if (!graphRef) {
                const messageApolloConfigurationRequired = 'APOLLO_GRAPH_REF must be set to use the operation registry.';
                throw new Error(`${common_1.pluginName}: ${messageApolloConfigurationRequired}`);
            }
            logger.debug(`Operation registry is configured for '${graphRef}'.`);
            store = new apollo_server_caching_1.InMemoryLRUCache({ maxSize: Infinity });
            logger.debug('Initializing operation registry agent...');
            agent = new agent_1.default({
                apollo: {
                    ...apollo,
                    graphRef,
                    keyHash,
                },
                store,
                logger,
                fetcher: options.fetcher,
            });
            await agent.start();
            return {
                async serverWillStop() {
                    agent.stop();
                },
            };
        },
        async requestDidStart() {
            return {
                async didResolveOperation(requestContext) {
                    const documentFromRequestContext = requestContext.document;
                    if (!store) {
                        throw new Error('Unable to access store.');
                    }
                    const normalizedDocument = apollo_graphql_1.defaultOperationRegistrySignature(documentFromRequestContext, requestContext.operationName || '');
                    const signature = apollo_graphql_1.operationHash(normalizedDocument);
                    if (!signature) {
                        throw new apollo_server_errors_1.ApolloError('No document.');
                    }
                    const logSignature = common_1.signatureForLogging(signature);
                    logger.debug(`${logSignature}: Looking up operation in local registry.`);
                    const storeFetch = await store.get(common_1.getStoreKey(signature));
                    if (storeFetch) {
                        logger.debug(`${logSignature}: Permitting operation found in local registry.`);
                        requestContext.metrics.registeredOperation = true;
                        return;
                    }
                    else {
                        if (typeof options.onUnregisteredOperation === 'function') {
                            const onUnregisteredOperation = options.onUnregisteredOperation;
                            Promise.resolve().then(() => {
                                onUnregisteredOperation(requestContext, {
                                    signature,
                                    normalizedDocument,
                                });
                            });
                        }
                    }
                    let shouldForbidOperation = typeof options.forbidUnregisteredOperations === 'boolean'
                        ? options.forbidUnregisteredOperations
                        : typeof options.forbidUnregisteredOperations === 'function';
                    if (typeof options.forbidUnregisteredOperations === 'function') {
                        logger.debug(`${logSignature}: Calling 'forbidUnregisteredOperations' predicate function with requestContext...`);
                        try {
                            const predicateResult = options.forbidUnregisteredOperations(requestContext);
                            logger.debug(`${logSignature}: The 'forbidUnregisteredOperations' predicate function returned ${predicateResult}`);
                            if (typeof predicateResult === 'boolean') {
                                shouldForbidOperation = predicateResult;
                            }
                            else {
                                logger.warn(`${logSignature} Predicate function did not return a boolean response. Got ${predicateResult}`);
                            }
                        }
                        catch (err) {
                            logger.error(`${logSignature}: An error occurred within the 'forbidUnregisteredOperations' predicate function: ${err}`);
                        }
                    }
                    if (!shouldForbidOperation) {
                        return;
                    }
                    if (options.forbidUnregisteredOperations) {
                        logger.debug(`${logSignature} Reporting operation as forbidden to Apollo trace warehouse.`);
                        requestContext.metrics.forbiddenOperation = true;
                    }
                    if (shouldForbidOperation) {
                        if (typeof options.onForbiddenOperation === 'function') {
                            const onForbiddenOperation = options.onForbiddenOperation;
                            Promise.resolve().then(() => {
                                onForbiddenOperation(requestContext, {
                                    signature,
                                    normalizedDocument,
                                });
                            });
                        }
                    }
                    if (options.dryRun) {
                        logger.debug(`${dryRunPrefix} ${logSignature}: Operation ${requestContext.operationName} would have been forbidden.`);
                        return;
                    }
                    logger.debug(`${logSignature}: Execution denied because 'forbidUnregisteredOperations' was enabled for this request and the operation was not found in the local operation registry.`);
                    const error = new apollo_server_errors_1.ForbiddenError('Execution forbidden: Operation not found in operation registry');
                    Object.assign(error.extensions, {
                        operationSignature: signature,
                        exception: {
                            message: `Please register your operation with \`npx apollo client:push --variant="${agent.graphVariant}"\`. See https://www.apollographql.com/docs/platform/operation-registry/ for more details.`,
                        },
                    });
                    throw error;
                },
            };
        },
    });
}
exports.default = plugin;
//# sourceMappingURL=ApolloServerPluginOperationRegistry.js.map